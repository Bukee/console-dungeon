# Console Dungeon

## Концепция

Игроки подключаются к игре с рандомно-сгенерированной структурой связных комнат. Все взаимодействия осуществляются через ввод команд и/или параметров к ним. Время игры ограничено 10 минутами. За это время игроки должны набрать как можно больше очков. Очки можно получить за поднятие предметов, успешные атаки на других игроков, открытие запертых комнат, победу над мобами. Очки можно потерять при дропе предмета в комнату.
Комнаты представляют собой списки игроков, предметов, которые можно взять, или выкинуть. В комнатах расположены монстры (генерируются один раз), которых можно атаковать (отдельная механика или атаковал – получил урон – убил). После сражения монстр даёт предмет, который нужно положить в инвентарь или выбросить (может зависеть от типа или класса монстра). Можно атаковать игроков, нанося им урон и получая его в ответ в размере, зависящем от экипированных игроками предметов. Урон наносится в разовом режиме: атаковал – получил сдачу – бой окончен. Есть закрытые комнаты, которые доступны для перемещения только при наличии специального предмета, складывающегося в отдельный слот – ключа. После перехода в такие комнаты ключ исчезает, а другие игроки могут входить в неё без траты ключа. На карте существует 2 комнаты-магазина, в которых игроки могут продавать/покупать предметы и не могут атаковать других игроков.
Игрок имеет ограниченное количество слотов инвентаря и доп. слот для ключей. У игрока есть здоровье, на него влияют атаки других игроков или мобов. Если здоровье опускается до 0, то игрок умирает, теряя очки и дропает предметы из инвентаря. Через определённое время игрок появится в выбранной сервером комнате и продолжит игру.
Предметы, которые игроки могут поднимать в комнатах или выбивать с мобов дают пассивные и активные навыки. Активные можно использовать, набрав определённые команды, пассивные действуют постоянно и влияют на базовые действия игроков. Предметы могут относиться к определённым наборам. Собрав все предметы из набора, игрок получит некоторые пассивные или активные бонусы.

## Задачи

0. Механика боя с игроками, взаимодействие с другими механиками и структурами, базовые структуры. **_Делает Артём Онянов_**

1. Создание структур предметов (основополагающей, то есть без расширений, а задающей шаблон структуры): подклассы предметов (в зависимости от того, будет ли предмет как-то влиять на игровой процесс сам по себе), стоимость предмета в очках. ***Делает Дарья Фильчукова, Кирилл Кузнецов***

2. Появление игрока на карте: размещение в комнате с определёнными условиями (количество игроков, их очки и т.д.). **_Делает Илья Дылько_**

3. Дроп предметов после смерти (определённое количество или на основании критериев предметов, или иначе по вольной интерпретации). **_Делает Артём Айрапетов_**

4. Генерация карты: связный граф комнат, генерация закрытых комнат. **_Делает Андрей Косиков_**

5. Мобы: структура моба (создание основополагающей структуры моба, задающей шаблон взаимодействия для механики боя, если такая будет) и возможный дроп с моба после сражения или предопределённый структурой моба (в любом случае дроп - определённый предмет). ***Делает Ярослав Буков***

6. Генерация предметов и монстров : заполнять списки предметов и монстров в комнатах на основе их "редкости", параметров и прочего. ***Делает Виктория Чупилко*** 

7. Проработка механик предметов: основываясь на структуре предметов из пункта 1, реализовать активные способности предметов, применяемые при наборе команд (то есть реализация таких команд), влияющих на структуру игроков или комнат. Например, не менее 5 различных команд. ***Делает Кирилл Кузнецов***

8. Проработка характеристик предметов: основываясь на структуре предметов из пункта 1, реализовать пассивные функции предметов, которые будут вызываться при базовых действиях игроков, например, при атаке (возможно, какой-нибудь модификатор урона/блокировка урона), переходе в другие комнаты, поднятии предметов и т.п. Скажем, не менее 5 различных команд. ***Делает Алексей Шляховой, Илья Панасенко***

9. Магазин: реализация комнаты, в которой возможен трейдинг предметов ,основанный на очках, либо между игроками, либо какому-нибудь продавцу, то есть работа с базовыми структурами инвентаря, игрока (вычитание/сложение очков). ***Делает Диана Мартемьянова***

10. Наборы предметов: предметы со структурой из пункта 1 определённых типов (или классов) составляют набор предметов, который даёт бонусы пассивные или активные (можно связать с уже реализованными механиками в пунктах 7, 8). ***Делает Дарья Фильчукова***


## Что будет, было сделано

0. Механика боя с игроками, взаимодействие с другими механиками и структурами, базовые структуры. **_Делает Артём Онянов_**

    Команды:

    * score – выводи таблицу очков
    * attack n – атака н-того игрока в комнате. При атаке игроки обмениваются уроном только если это не добивавши удар
    * status – выводит количество хп и очков 

    Были добавлены:

    Файл player (более подробное описание функций в коде):
    * переменная для хранения количества ключей
    * добавлена мапа хп игроков, где ключ имя игрока а значении количество хп
    * добавлена мапа значений величии атак игроков игроков, где ключ имя игрока а значении величина атаки
    * добавлена мапа очков игроков, где ключ имя игрока а значении очки игрока
    * константы:
        * max-health – максимальное хп игрока
        * base-attack-value – базовая атака игрока
        * respawn-time – время респ
        * points-for-kill – очки за убийство игрока
        * target-score – количество очков для завершения игры
        * eol – константа переноса на новую строку
    * атом finished – закончена ли игра
    * были добавлены функции
        * функция game-is-finished? Возвращает true если игра завершилась false если нет
        * функция add-points добавляет очки текшему игроку
        * функция set-health-value устанавливает указанному игроку указанное количество хп
        * функция kill-player-for убивает указанного игрока на указанное количество секунд также передается комната, в которой он находится
        * функция attack наносит урон игроку
        * функция get-health возвращает хп игрока  

    Файл commands:

    Доработанны:
    * в функцию look добавлено отображения игроков в комнате 
    * доработан метод подъёма предметов теперь при подъёме ключей ключи не кладутся в инвентарь вместо этого увеличивается счетчик ключей
    * доработан метод выбрасывания предметов теперь при выбрасывании ключа счетчик ключей уменьшается и ключи помешаются в инвентарь комнаты (нет проверки на отрицательное количество ключей) 
    * функция inventory давлено отображение количество ключей 
    Новые функции: 
    * score – отображение таблицы очков
    * get-points – добавляет больше очков игроку для дебага
    * attack – атакует н-того игрока н указывается
    Файл server:
    * Добавлена инициализация всех параметров игрока
    * проверка жив ли игрок если нет, то выводится сообщение о что он умер
    * проверка завершения игры
    * вывоз лидерборда после завершения игры



# Readme.md из оригинального mire

## Usage

Install [Leiningen](http://leiningen.org) if you haven't already:

    $ curl -O ~/bin/lein http://github.com/technomancy/leiningen/raw/stable/bin/lein
    $ chmod 755 bin/lein

Then do `lein run` inside the Mire directory to launch the Mire
server. Then players can connect by telnetting to port 3333.

## Motivation

This code is not that interesting as a game, though I suppose
something fun could be built using it as a base. The primary purpose
of it is as a demonstration of how to build a simple multithreaded app
in Clojure.

Mire is built up step-by-step, where each step introduces one or two
small yet key Clojure principles and builds on the last step. The
steps each exist in separate git branches. To get the most out of
reading Mire, you should start reading in the branch called
[step-01-echo-server](http://github.com/technomancy/mire/tree/01-echo-server)
and continue from there.

While you can learn from Mire on its own, it has been written
specifically for the [PeepCode screencast on
Clojure](http://peepcode.com/products/functional-programming-with-clojure).
A [blog post](http://technomancy.us/136) steps through the codebase
and shows how to make minor updates for a more recent version of Clojure.

Copyright © 2009-2012 Phil Hagelberg
Licensed under the same terms as Clojure.
